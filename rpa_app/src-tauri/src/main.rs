// ============================================================================
// 第一部分：Windows 平台特定的配置（防止显示控制台窗口）
// ============================================================================

// 这是注释，说明这行代码的作用
// 中文翻译：在 Windows 发布版本中防止显示额外的控制台窗口，不要删除！！
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
// 
// 解释：
//   - 在 Windows 上，默认情况下运行 Rust 程序会弹出一个黑色的控制台窗口
//   - 对于图形界面应用（如 Tauri），这个控制台窗口是不需要的
//   - 这行代码的作用就是隐藏这个控制台窗口，让应用看起来更专业

// #![...] 是 Rust 的"内部属性"（Inner Attribute）
// 注意：开头的 #! 表示这是应用到整个 crate（项目）的属性，而不是单个项目
// 
// cfg_attr 是 Rust 的条件编译属性宏
// 语法：cfg_attr(条件, 属性)
// 含义：如果满足"条件"，则应用"属性"
// 
// not(debug_assertions) 的含义：
//   - debug_assertions 是 Rust 的内置配置选项
//   - 在调试模式（debug）下，debug_assertions 为 true
//   - 在发布模式（release）下，debug_assertions 为 false
//   - not(debug_assertions) 表示"不是调试模式"，即"是发布模式"
// 
// windows_subsystem = "windows" 的含义：
//   - 这是 Windows 特定的链接器选项
//   - "windows" 子系统表示这是一个图形界面应用，不需要控制台
//   - 如果设置为 "console"，则会显示控制台窗口
// 
// 整体含义：
//   只在发布模式（release build）下，将应用设置为 Windows 子系统
//   这样在发布版本中就不会显示控制台窗口
//   但在调试模式下，仍然会显示控制台窗口（方便查看日志和调试信息）
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
// ============================================================================
// 第二部分：程序的入口点函数
// ============================================================================

// fn 是 Rust 中定义函数的关键字
// main 是函数名，这是 Rust 程序的入口点（Entry Point）
// 当程序启动时，Rust 会首先执行 main() 函数
// 
// 注意：main() 函数没有参数，也没有返回值
// 这是 Rust 程序的标准入口点格式
fn main() {
    // tauri_lesson_1_lib 是我们在 Cargo.toml 中定义的库名称
    // :: 是 Rust 的路径分隔符，用于访问模块中的函数
    // run() 是 lib.rs 中定义的公开函数（pub fn run）
    // 
    // 这行代码的作用：
    //   调用 lib.rs 中的 run() 函数来启动 Tauri 应用
    //   所有的应用配置和启动逻辑都在 lib.rs 的 run() 函数中
    // 
    // 为什么不在 main() 中直接写启动代码？
    //   1. 代码组织：将业务逻辑放在 lib.rs，main.rs 只负责调用
    //   2. 可测试性：lib.rs 中的代码更容易进行单元测试
    //   3. 可重用性：lib.rs 可以被其他项目作为库使用
    //   4. 移动平台：在 iOS/Android 上，入口点不同，但可以共用 lib.rs 的代码
    tauri_lesson_1_lib::run()
    // 注意：这行代码没有分号，表示这是一个表达式，会返回 run() 的结果
    // 但实际上 run() 不会返回（它会一直运行直到应用关闭）
}


